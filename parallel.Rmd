---
title: "imager in parallel"
output:
  html_document:
    toc: true
    number_sections: true
---    

[Simon Barthelm√©](http://sites.google.com/site/simonbarthelme) (GIPSA-lab, CNRS)

There are several ways of doing things in parallel with imager. One of them is to use of R's many packages for doing things in parallel  (parallel, futures, etc.). The other one is to take advantage of CImg's ative use of OpenMP.

# Parallelising from R

Parallelising from R is very easy (provided that what you want to do actually parallelises). Something that does parallelise easily is to run the same operations on different images, or on different image channels. 

```{r}
library(imager)
library(parallel)

#A really big image
im <- boats %>% imresize(8)
#Rank pixels in each image channel 
#Serial version 
fun <- function() imsplit(im,"c") %>% lapply(rank)
    
system.time(fun())

#Parallel version: use mclapply
fun.par <- function() imsplit(im,"c") %>% mclapply(rank,mc.cores=2)
system.time(fun.par())
```



# Native parallelisation: CImg and OpenMP

Many CImg operations are parallelised natively. The parallelisation is optional and is only activated starting from a certain image size. The speed-ups are sublinear, meaning that unless your image is gigantic you won't gain much from throwing 200 cores at a problem. 

By default OpenMP will grab all the CPU cores it can. To correctly use multiple threads users should set nthreads in cimg.use.openmp. You also need to be careful that this is not higher than the value in the system environment variable OMP_THREAD_LIMIT (this can be checked with Sys.getenv('OMP_THREAD_LIMIT')). The OMP_THREAD_LIMIT thread limit usually needs to be correctly set before launching R, so using Sys.setenv once a session has started is not certain to work.

```{r}
library(imager)
library(microbenchmark)
#Let's do a big convolution
a <- boats
b <- imnoise(30,30) 
fun <- function() convolve(a,b)
#No parallelisation
cimg.use.openmp(nthreads = 1)
microbenchmark(fun(),times=15)

#2 cores
cimg.use.openmp(nthreads = 2)
microbenchmark(fun(),times=15)

#4 cores, etc.
cimg.use.openmp(nthreads = 4)
microbenchmark(fun(),times=15)
```

If CImg's parallelisation doesn't seem to work on your machine, it's probably because you compiled the package with Clang, which has patchy support for OpenMP. Recompile using gcc if possible. For macOS check here: https://mac.r-project.org/openmp/

# Parallelisation in R vs. native parallelisation 

Here's a simple benchmark: medianblur can be parallelised across image channels. First, the R version using mclapply:

```{r}
cimg.use.openmp(nthreads = 1)
fun.R <- function() imsplit(boats,"c") %>% mclapply(function(v) medianblur(v,50),mc.cores=3)
microbenchmark(fun.R(),times=20)
```

Second, CImg's native version:

```{r}
cimg.use.openmp(nthreads = 4)
fun.nat <- function() medianblur(boats,50)
microbenchmark(fun.nat(),times=20)
```



Pros and cons of using native parallelisation:

- Transparent
- Very efficient if you work on large images
- Only works on compatible platforms (i.e., needs gcc)

Pros and cons of parallelisation from R:

- More flexible (futures, multiple threads, etc.)
- Effective if you run a long chain of operations over many images
- Better cross-platform support
- Slightly less transparent and possibly slower

Note that both types of parallelisation can be combined if you can spread the load over several machines. 
